{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hydration This software has been designed for you, with much joy, by Michael Shustin You can find the complete documentation here What is Hydration? Hydration is a library used to define python objects that can be converted to (and from) bytes. Installation pip install hydration Introduction This guide assumes you are familiar with low-level primitive data types (like signed/unsigned int, int64, etc.) Field Fields are primitive objects that hold data, and can be converted to (and from) bytes: >>> from hydration import * >>> f = UInt16 ( 1512 ) >>> bytes ( f ) b'\\xe8\\x05' >>> UInt16 () . from_bytes ( b ' \\xe8\\x05 ' ) UInt16(1512) Struct A struct is a composite of fields. To create a struct, Inherit from Struct : from hydration import * class MyStruct ( Struct ): a = UInt8 b = UInt8 ( value = 3 ) # You can set the default value >>> st = MyStruct ( a = 10 ) # Structs can receive field values as keyword arguments >>> print ( st ) MyStruct a: UInt8(10) b: UInt8(3) >>> bytes ( st ) b'\\n\\x03' >>> print ( MyStruct . from_bytes ( b ' \\n\\x03 ' )) MyStruct: a: UInt8(10) b: UInt8(3) Message A message is a list-like composite of structs: from hydration import * class Header ( Struct ): magic = UInt32 ( 0xDEADBEEF ) class Body ( Struct ): param1 = Float ( 2.875 ) param2 = Int8 ( - 128 ) >>> msg = Header () / Body () # Create a message by using the division operator on structs >>> print ( msg ) Header: magic: UInt32(3735928559) Body: param1: Float(2.875) param2: Int8(-128) >>> bytes ( msg ) b'\\xef\\xbe\\xad\\xde\\x00\\x008@\\x80' Advanced features For more advanced usage, be sure to check the documentation . Support Want to report a bug? Request a feature? Please do so here Maintainers Michael Shustin (Author) Aviv Atedgi","title":"Introduction"},{"location":"#hydration","text":"This software has been designed for you, with much joy, by Michael Shustin You can find the complete documentation here","title":"Hydration"},{"location":"#what-is-hydration","text":"Hydration is a library used to define python objects that can be converted to (and from) bytes.","title":"What is Hydration?"},{"location":"#installation","text":"pip install hydration","title":"Installation"},{"location":"#introduction","text":"This guide assumes you are familiar with low-level primitive data types (like signed/unsigned int, int64, etc.)","title":"Introduction"},{"location":"#field","text":"Fields are primitive objects that hold data, and can be converted to (and from) bytes: >>> from hydration import * >>> f = UInt16 ( 1512 ) >>> bytes ( f ) b'\\xe8\\x05' >>> UInt16 () . from_bytes ( b ' \\xe8\\x05 ' ) UInt16(1512)","title":"Field"},{"location":"#struct","text":"A struct is a composite of fields. To create a struct, Inherit from Struct : from hydration import * class MyStruct ( Struct ): a = UInt8 b = UInt8 ( value = 3 ) # You can set the default value >>> st = MyStruct ( a = 10 ) # Structs can receive field values as keyword arguments >>> print ( st ) MyStruct a: UInt8(10) b: UInt8(3) >>> bytes ( st ) b'\\n\\x03' >>> print ( MyStruct . from_bytes ( b ' \\n\\x03 ' )) MyStruct: a: UInt8(10) b: UInt8(3)","title":"Struct"},{"location":"#message","text":"A message is a list-like composite of structs: from hydration import * class Header ( Struct ): magic = UInt32 ( 0xDEADBEEF ) class Body ( Struct ): param1 = Float ( 2.875 ) param2 = Int8 ( - 128 ) >>> msg = Header () / Body () # Create a message by using the division operator on structs >>> print ( msg ) Header: magic: UInt32(3735928559) Body: param1: Float(2.875) param2: Int8(-128) >>> bytes ( msg ) b'\\xef\\xbe\\xad\\xde\\x00\\x008@\\x80'","title":"Message"},{"location":"#advanced-features","text":"For more advanced usage, be sure to check the documentation .","title":"Advanced features"},{"location":"#support","text":"Want to report a bug? Request a feature? Please do so here","title":"Support"},{"location":"#maintainers","text":"Michael Shustin (Author) Aviv Atedgi","title":"Maintainers"},{"location":"fields/","text":"Fields Fields are the primitive objects that hold data, and can be converted to (and from) bytes >>> from hydration import * >>> f = UInt16 ( 1512 ) >>> bytes ( f ) b'\\xe8\\x05' >>> UInt16 () . from_bytes ( b ' \\xe8\\x05 ' ) UInt16(1512) Scalars Scalars are simple fields that represent low-level primitive data types: Scalar class Size UInt8 1 byte UInt16 2 bytes UInt32 4 bytes UInt64 8 bytes Int8 1 byte Int16 2 bytes Int32 4 bytes Int64 8 bytes Float 4 bytes Double 8 bytes Validation Fields have a validator keyword argument, which allows you catch errors during early stages of the object creation, whether by construction or from_bytes from hydration import * range_ok = UInt8 ( validator = range ( 3 )) list_ok = UInt8 ( validator = [ 10 , 20 ]) >>> range_ok . value = 4 ValueError: Given value 4 is not in range(0, 3) >>> list_ok . value = 5 ValueError: Given value 5 is not in {0, 10, 20} Endianness You can control the endianness of scalars that are longer than 1 byte: >>> bytes ( UInt32 ( 3 , endianness = BigEndian )) b'\\x00\\x00\\x00\\x03' >>> bytes ( UInt32 ( 3 , endianness = LittleEndian )) b'\\x03\\x00\\x00\\x00' NOTE: The default endianness is that of your architecture, so it might be different on other processor architectures. Enum Enums are scalars that makes working with enum.IntEnum easier. from enum import IntEnum class Color ( IntEnum ): RED = 1 GREEN = 2 BLUE = 3 By using enums, you get clean, readable code. The constructor receives the class of the Enum and takes care of initialization and validation for you. (The default value is the first enum) >>> field = Enum ( UInt8 , Color ) >>> field . name 'RED' >>> field . value 1 >>> field . value = 4 ValueError: 4 is not a valid Color Sequences Sequences are homogeneous collection of fields or structs, e.g. Array and Vector Array Arrays are sequences of constant size >>> bytes ( Array ( 3 , value = [ 1 , 2 , 3 ])) b'\\x01\\x02\\x03' By default, an Array is a construct of UInt8 s, this can be changed. >>> bytes ( Array ( 3 , field_type = UInt16 , value = [ 1 , 2 , 3 ])) b'\\x01\\x00\\x02\\x00\\x03\\x00' Notice that an Array has a fixed size. If the given value doesn't fill the array, the rest of the scalars will have the default field_type value (usually 0): >>> print ( Array ( 6 , value = ( 3 , 4 ))) Array(3, 4, 0, 0, 0, 0) >>> print ( Array ( 5 , field_type = UInt8 ( 5 ), value = ( 3 , 4 ))) Array(3, 4, 5, 5, 5, 5) Vector Vectors are sequences of variable size, and can only be used inside a Struct , so it is documented in docs/struct.md","title":"Fields"},{"location":"fields/#fields","text":"Fields are the primitive objects that hold data, and can be converted to (and from) bytes >>> from hydration import * >>> f = UInt16 ( 1512 ) >>> bytes ( f ) b'\\xe8\\x05' >>> UInt16 () . from_bytes ( b ' \\xe8\\x05 ' ) UInt16(1512)","title":"Fields"},{"location":"fields/#scalars","text":"Scalars are simple fields that represent low-level primitive data types: Scalar class Size UInt8 1 byte UInt16 2 bytes UInt32 4 bytes UInt64 8 bytes Int8 1 byte Int16 2 bytes Int32 4 bytes Int64 8 bytes Float 4 bytes Double 8 bytes","title":"Scalars"},{"location":"fields/#validation","text":"Fields have a validator keyword argument, which allows you catch errors during early stages of the object creation, whether by construction or from_bytes from hydration import * range_ok = UInt8 ( validator = range ( 3 )) list_ok = UInt8 ( validator = [ 10 , 20 ]) >>> range_ok . value = 4 ValueError: Given value 4 is not in range(0, 3) >>> list_ok . value = 5 ValueError: Given value 5 is not in {0, 10, 20}","title":"Validation"},{"location":"fields/#endianness","text":"You can control the endianness of scalars that are longer than 1 byte: >>> bytes ( UInt32 ( 3 , endianness = BigEndian )) b'\\x00\\x00\\x00\\x03' >>> bytes ( UInt32 ( 3 , endianness = LittleEndian )) b'\\x03\\x00\\x00\\x00' NOTE: The default endianness is that of your architecture, so it might be different on other processor architectures.","title":"Endianness"},{"location":"fields/#enum","text":"Enums are scalars that makes working with enum.IntEnum easier. from enum import IntEnum class Color ( IntEnum ): RED = 1 GREEN = 2 BLUE = 3 By using enums, you get clean, readable code. The constructor receives the class of the Enum and takes care of initialization and validation for you. (The default value is the first enum) >>> field = Enum ( UInt8 , Color ) >>> field . name 'RED' >>> field . value 1 >>> field . value = 4 ValueError: 4 is not a valid Color","title":"Enum"},{"location":"fields/#sequences","text":"Sequences are homogeneous collection of fields or structs, e.g. Array and Vector","title":"Sequences"},{"location":"fields/#array","text":"Arrays are sequences of constant size >>> bytes ( Array ( 3 , value = [ 1 , 2 , 3 ])) b'\\x01\\x02\\x03' By default, an Array is a construct of UInt8 s, this can be changed. >>> bytes ( Array ( 3 , field_type = UInt16 , value = [ 1 , 2 , 3 ])) b'\\x01\\x00\\x02\\x00\\x03\\x00' Notice that an Array has a fixed size. If the given value doesn't fill the array, the rest of the scalars will have the default field_type value (usually 0): >>> print ( Array ( 6 , value = ( 3 , 4 ))) Array(3, 4, 0, 0, 0, 0) >>> print ( Array ( 5 , field_type = UInt8 ( 5 ), value = ( 3 , 4 ))) Array(3, 4, 5, 5, 5, 5)","title":"Array"},{"location":"fields/#vector","text":"Vectors are sequences of variable size, and can only be used inside a Struct , so it is documented in docs/struct.md","title":"Vector"},{"location":"messages/","text":"Message A message is a list-like composite of structs: from hydration import * class Header ( Struct ): magic = UInt32 ( 0xDEADBEEF ) class Body ( Struct ): param1 = Float ( 2.875 ) param2 = Int8 ( - 128 ) >>> msg = Header () / Body () # Create a message by using the division operator on structs >>> print ( msg ) Header: magic: UInt32(3735928559) Body: param1: Float(2.875) param2: Int8(-128) >>> bytes ( msg ) b'\\xef\\xbe\\xad\\xde\\x00\\x008@\\x80' MetaField Messages allow the usage of another type of field, called MetaField , Length Let's assume you want to include the length of the struct in the header. The value of the InclusiveLengthField will be equal to the length of the following structs of the message (including its own struct): from hydration import * class Header1 ( Struct ): message_len = InclusiveLengthField ( UInt16 ) class Body1 ( Struct ): some_data = UInt64 ( 0xAABB ) print(Header1() / Body1()) Header1: message_len: UInt16(10) Body1: some_data: UInt64(43707) As you can see, the value of message_len is 10. (2 byte-long header, and 8 byte-long body) You can also use an ExclusiveLengthField . In which case, the field's length calculation excludes the length of its own struct: from hydration import * class Header2 ( Struct ): message_len = ExclusiveLengthField ( UInt16 ) >>> print ( Header2 () / Body1 ()) Header2: message_len: UInt16(8) Body1: some_data: UInt64(43707) Now the value of message_len is 8. Opcode An OpcodeField will update automatically based on a given mapping from hydration import * class Body2 ( Struct ): data2 = UInt32 ( 20 ) class Body3 ( Struct ): data3 = UInt64 ( 40 ) opcode_dict = { Body2 : 1 , Body3 : 2 , } class Header3 ( Struct ): opcode = OpcodeField ( UInt32 , opcode_dict ) >>> print ( Header3 () / Body2 ()) Header3: opcode: UInt32(1) Body2: data2: UInt32(20) >>> print ( Header3 () / Body3 ()) Header3: opcode: UInt32(2) Body3: data3: UInt64(40)","title":"Messages"},{"location":"messages/#message","text":"A message is a list-like composite of structs: from hydration import * class Header ( Struct ): magic = UInt32 ( 0xDEADBEEF ) class Body ( Struct ): param1 = Float ( 2.875 ) param2 = Int8 ( - 128 ) >>> msg = Header () / Body () # Create a message by using the division operator on structs >>> print ( msg ) Header: magic: UInt32(3735928559) Body: param1: Float(2.875) param2: Int8(-128) >>> bytes ( msg ) b'\\xef\\xbe\\xad\\xde\\x00\\x008@\\x80'","title":"Message"},{"location":"messages/#metafield","text":"Messages allow the usage of another type of field, called MetaField ,","title":"MetaField"},{"location":"messages/#length","text":"Let's assume you want to include the length of the struct in the header. The value of the InclusiveLengthField will be equal to the length of the following structs of the message (including its own struct): from hydration import * class Header1 ( Struct ): message_len = InclusiveLengthField ( UInt16 ) class Body1 ( Struct ): some_data = UInt64 ( 0xAABB ) print(Header1() / Body1()) Header1: message_len: UInt16(10) Body1: some_data: UInt64(43707) As you can see, the value of message_len is 10. (2 byte-long header, and 8 byte-long body) You can also use an ExclusiveLengthField . In which case, the field's length calculation excludes the length of its own struct: from hydration import * class Header2 ( Struct ): message_len = ExclusiveLengthField ( UInt16 ) >>> print ( Header2 () / Body1 ()) Header2: message_len: UInt16(8) Body1: some_data: UInt64(43707) Now the value of message_len is 8.","title":"Length"},{"location":"messages/#opcode","text":"An OpcodeField will update automatically based on a given mapping from hydration import * class Body2 ( Struct ): data2 = UInt32 ( 20 ) class Body3 ( Struct ): data3 = UInt64 ( 40 ) opcode_dict = { Body2 : 1 , Body3 : 2 , } class Header3 ( Struct ): opcode = OpcodeField ( UInt32 , opcode_dict ) >>> print ( Header3 () / Body2 ()) Header3: opcode: UInt32(1) Body2: data2: UInt32(20) >>> print ( Header3 () / Body3 ()) Header3: opcode: UInt32(2) Body3: data3: UInt64(40)","title":"Opcode"},{"location":"structs/","text":"Struct A struct is a composite of fields. To create a struct, Inherit from Struct to combine multiple fields: from hydration import * class MyStruct ( Struct ): a = UInt8 b = UInt8 ( value = 3 ) # You can set the default value >>> st = MyStruct ( a = 10 ) # Structs can receive field values as keyword arguments >>> print ( st ) MyStruct a: UInt8(10) b: UInt8(3) >>> bytes ( st ) b'\\n\\x03' >>> print ( MyStruct . from_bytes ( b ' \\n\\x03 ' )) MyStruct: a: UInt8(10) b: UInt8(3) Structs are also mutable, so you can set field values without explicitly accessing their value property: >>> st = MyStruct ( a = 10 ) >>> st . b = 5 >>> print ( st ) MyStruct a: UInt8(10) b: UInt8(5) Endianness When defining a Struct, you may set the default Endianness for all of its scalars: from hydration import * class Clean ( Struct , endianness = BigEndian ): a = UInt64 b = UInt32 c = UInt16 ( endianness = LittleEndian ) d = UInt8 The endianness of the fields will always override the one of their struct. In this case, c will be in LittleEndian. Note that endianness doesn't affect d , because it's a UInt8 . It can't \"have\" endianness Vectors A vector is a dynamic length sequence. The length of the vector needs to be the value of another field in the struct. from hydration import * class Dynamic ( Struct ): vec_len = UInt16 () vector = Vector ( length = vec_len ) >>> st = Dynamic () >>> st . vector = [ 1 , 2 , 3 ] >>> print ( st ) Dynamic: vec_len: UInt16(3) vector: Vector[1, 2, 3] Notice that vec_len has been updated automatically. By default, the vector is a sequence of UInt8 , but this can be changed: from hydration import * class Dynamic ( Struct ): vec_len = UInt16 () vector = Vector ( length = vec_len , field_type = UInt32 ) >>> st = Dynamic () >>> st . vector = [ 1 , 2 , 3 ] >>> bytes ( st ) b'\\x03\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00' Inheritance Sometimes, some structs have common fields, in which case - they can be separated to reduce code duplication: from hydration import * class Common ( Struct ): common_a = UInt64 class Specific ( Common ): specific = UInt32 >>> print ( Specific ()) Specific: common_a: UInt64(0) specific: UInt32(0) Inheriting classes will prepend their fields before the fields of the subclass, to append them instead, use footer=True : from hydration import * class CommonFooter ( Struct , footer = True ): common_a = UInt64 class Specific ( CommonFooter ): specific = UInt32 >>> print ( Specific ()) Specific: specific: UInt32(0) common_a: UInt64(0) Multiple inheritance is also possible, albeit not recommended: from hydration import * class Header1 ( Struct ): a = UInt8 class Header2 ( Struct ): b = UInt8 class Specific ( Header1 , Header2 ): c = UInt16 >>> print ( Specific ()) Specific: a: UInt8(0) b: UInt8(0) c: UInt16(0) Subclassing a Struct will only inherit the fields. It doesn't inherit endianness or footer .","title":"Structs"},{"location":"structs/#struct","text":"A struct is a composite of fields. To create a struct, Inherit from Struct to combine multiple fields: from hydration import * class MyStruct ( Struct ): a = UInt8 b = UInt8 ( value = 3 ) # You can set the default value >>> st = MyStruct ( a = 10 ) # Structs can receive field values as keyword arguments >>> print ( st ) MyStruct a: UInt8(10) b: UInt8(3) >>> bytes ( st ) b'\\n\\x03' >>> print ( MyStruct . from_bytes ( b ' \\n\\x03 ' )) MyStruct: a: UInt8(10) b: UInt8(3) Structs are also mutable, so you can set field values without explicitly accessing their value property: >>> st = MyStruct ( a = 10 ) >>> st . b = 5 >>> print ( st ) MyStruct a: UInt8(10) b: UInt8(5)","title":"Struct"},{"location":"structs/#endianness","text":"When defining a Struct, you may set the default Endianness for all of its scalars: from hydration import * class Clean ( Struct , endianness = BigEndian ): a = UInt64 b = UInt32 c = UInt16 ( endianness = LittleEndian ) d = UInt8 The endianness of the fields will always override the one of their struct. In this case, c will be in LittleEndian. Note that endianness doesn't affect d , because it's a UInt8 . It can't \"have\" endianness","title":"Endianness"},{"location":"structs/#vectors","text":"A vector is a dynamic length sequence. The length of the vector needs to be the value of another field in the struct. from hydration import * class Dynamic ( Struct ): vec_len = UInt16 () vector = Vector ( length = vec_len ) >>> st = Dynamic () >>> st . vector = [ 1 , 2 , 3 ] >>> print ( st ) Dynamic: vec_len: UInt16(3) vector: Vector[1, 2, 3] Notice that vec_len has been updated automatically. By default, the vector is a sequence of UInt8 , but this can be changed: from hydration import * class Dynamic ( Struct ): vec_len = UInt16 () vector = Vector ( length = vec_len , field_type = UInt32 ) >>> st = Dynamic () >>> st . vector = [ 1 , 2 , 3 ] >>> bytes ( st ) b'\\x03\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'","title":"Vectors"},{"location":"structs/#inheritance","text":"Sometimes, some structs have common fields, in which case - they can be separated to reduce code duplication: from hydration import * class Common ( Struct ): common_a = UInt64 class Specific ( Common ): specific = UInt32 >>> print ( Specific ()) Specific: common_a: UInt64(0) specific: UInt32(0) Inheriting classes will prepend their fields before the fields of the subclass, to append them instead, use footer=True : from hydration import * class CommonFooter ( Struct , footer = True ): common_a = UInt64 class Specific ( CommonFooter ): specific = UInt32 >>> print ( Specific ()) Specific: specific: UInt32(0) common_a: UInt64(0) Multiple inheritance is also possible, albeit not recommended: from hydration import * class Header1 ( Struct ): a = UInt8 class Header2 ( Struct ): b = UInt8 class Specific ( Header1 , Header2 ): c = UInt16 >>> print ( Specific ()) Specific: a: UInt8(0) b: UInt8(0) c: UInt16(0) Subclassing a Struct will only inherit the fields. It doesn't inherit endianness or footer .","title":"Inheritance"}]}